<%doc>

=head1 NAME

/tools/sequence.mas - mason module to display a sequence, either as
fasta text or as nicely formatted html, with optional highlighting of
sub-regions.

=head1 ARGUMENTS

=over 5

=item seq

the sequence [Bio::Seq object]

=item highlight_description

short plain-text description of the meaning of the highlighted regions,
defaults to 'matches'

=item highlight_coords

a list of ONE-BASED refs to start/end coords, [start, end], [start,
end], ...  Will be highlighted and sequence will be trimmed to show
only a window around these regions, unless whole_seq is set below.

=item whole_seq

Display the entire sequence, do not cut out windows around the
matches.  Default false.

=item width

width in characters to render the sequence, default 90

=item source

optional source name for the sequence, example "BLAST database such
and such", or "Tomato unigene build blah blah"

=back

=head1 AUTHOR

Lukas Mueller <lam87@cornell.edu>

=cut

</%doc>

<%args>
$seq
$highlight_description => 'matches'
$highlight_coords      => [ ]
$width     => 100
$source    => '<span class="ghosted">not recorded</span>'
$whole_seq => 0
</%args>

<%init>

# sanitize the coords array (add 0 to all the numbers in it, forcing them to be purely numeric)
$highlight_coords = [ map [map $_+0, @$_], @$highlight_coords ];

</%init>

<% info_section_html( title    => $seq->id,
                      contents => info_table_html( 'Sequence ID' => link_identifier($seq->id) || $seq->id,
                                                   'Length'      => commify_number( $seq->length ),
                                                   'Source'      => $source,
                                                   __multicol    => 3,
                                                   __border      => 0,
                                                  )
                                . info_table_html( 'Description' => $seq->desc || '<span class="ghosted">none</span>',
                                                   highlighted_regions( $highlight_coords, $highlight_description ),
                                                   __border => 0,
                                                  )
                                . seq_html( $seq, $highlight_coords, $width, $whole_seq ),
                     ) %>



<%once>
use List::Util qw/ min max /;
use List::MoreUtils qw/ minmax /;
use POSIX;
use Storable 'dclone';

use Bio::Range ();

use CXGN::Page::FormattingHelpers qw(
   html_string_linebreak_and_highlight
   info_section_html
   info_table_html
  );

use CXGN::Tools::Identifiers qw/ link_identifier /;
use CXGN::Tools::Text qw/ commify_number /;

use constant LINE_WINDOW_EXPAND => 5;

sub whole_seq_info_table {
    my ( $seq, $lines, $coords, $highlight_description,  ) = @_;

    return info_table_html( 'Sequence' =>
                                join( '',
                                      '<span class="sequence">',
                                      ( '&gt;',
                                        $seq->id,
                                        "<br />",
                                        join('<br />',@$lines),
                                      ),
                                      '</span>'
                                     ),
                            __border      => 0,
                           );
}

sub extract_subsequence_for_highlights {
    my ( $seq, $coords, $line_width ) = @_;

    return ( $seq, $coords ) unless $coords && @$coords;

    my @coord_range = minmax map @$_, @$coords;

    # round the coord range to the nearest line boundaries
    @coord_range = (
        $line_width * ( POSIX::floor( ($coord_range[0]-1) / $line_width ) - LINE_WINDOW_EXPAND )+1,
        $line_width * ( POSIX::ceil ( ($coord_range[1]-1) / $line_width ) + LINE_WINDOW_EXPAND )+1,
        );

    # clamp it to the boundaries of the sequence
    $coord_range[0] = max( 1           , $coord_range[0] );
    $coord_range[1] = min( $seq->length, $coord_range[1] );

    my $offset = $coord_range[0] - 1; #< zero-based offset

    return (
        # new sequence, the subsequence we are operating on
        Bio::PrimarySeq->new(
            -id   => $seq->id,
            -desc => $seq->desc,
            -seq  => $seq->subseq( @coord_range ),
            ),

        # abs to rel
        sub {  $_[0] - $offset },

        # rel to abs
        sub {  $_[0] + $offset },

        );
}

sub coords_to_ranges {
    my ( $seq, $coords ) = @_;
    return
        map {
            Bio::Range->new( -start => max( 1, $_->[0]),
                             -end   => min( $seq->length, $_->[1] ),
                            )
        }
        sort { $a->[0] <=> $b->[0] }
        @$coords;
}

sub seq_html {

    my $seq       = shift;
    my $coords    = shift;
    my $width     = shift;
    my $whole_seq = shift;

    # get our subsequence, plus 2 subroutine refs that convert
    # coordinates back and forth between being relative to the actual
    # sequence (absolute) and relative to the subsequence we are
    # operating on (relative)
    ( $seq, my ($abs2rel, $rel2abs) ) = extract_subsequence_for_highlights( $seq, $coords, $width );
    my @lines = $seq->seq =~ /.{1,$width}/gs;

    @$coords
        or return whole_seq_info_table($seq, \@lines);

    # convert the highlight coords to be relative to the subsequence
    # we are operating on
    for (@$coords) {
        for (@$_) {
            $_ = $abs2rel->( $_ );
        }
    }

    # change the coords into ranges and sort by start coord, also
    # clamping them to the sequence length if needed, and merge any
    # overlapping ranges
    my @ranges = Bio::Range->unions( coords_to_ranges( $seq, $coords ) );

    # put the highlighting span tags in the line-broken sequence
    foreach (@ranges) {
        my ($s,$e) = ($_->start - 1, $_->end - 1); #< convert to 0-based for this
        my @lines_used;
        my ( $s_line, $s_col ) = line_col( $s, $width );
        my ( $e_line, $e_col ) = line_col( $e, $width );

        #mark up the lines we're using
        if( $s_line == $e_line ) {
            my $ins_width = $e_col-$s_col+1;
            $lines[$s_line] =~ s|^(.{$s_col})(.{$ins_width})(.*)$|$1<span class="highlighted">$2</span>$3|s;
        } else {
            $lines[$s_line] =~ s|^(.{$s_col})(.*)$|$1<span class="highlighted">$2|s;
            my $ecol_n = $e_col+1;
            $lines[$e_line] =~ s|^(.{1,$ecol_n})(.*)$|$1</span>$2|s;
        }
    }

    # return all the lines if we're using the whole seq
    if( $whole_seq ) {
        return whole_seq_info_table( $seq, \@lines, $coords );
    }

    my @windows =
       # calculate 0-based non-overlapping ranges of lines we need
       Bio::Range->unions(
           map {
               my $r = $_;
               my $match = Bio::Range->new(
                   -start => max( 0,
                                  POSIX::floor(($r->start-1)/$width)-LINE_WINDOW_EXPAND,
                                ),
                   -end   => min( POSIX::floor( $seq->length/$width ),
                                  POSIX::floor( ($r->end-1)/$width )+LINE_WINDOW_EXPAND,
                                ),
                  );
           } @ranges
       );

    # special case: if the matches plus the windows actually cause the
    # whole sequence to be displayed, display a bit differently
    if( @windows == 1 && $windows[0]->start == 0 && $windows[0]->end == $#lines && $rel2abs->(1) == 1 ) {
        return whole_seq_info_table( $seq, \@lines, $coords );
    }

    # return just the lines in our window if not using the whole seq
    my $match_regions =
       # and extract those lines
       join '',
       map {
           my $abs_window_start = $rel2abs->( $_->start*$width + 1 );
           my $abs_window_end   = $rel2abs->( min( $seq->length, ($_->end+1)*$width ) );
           info_section_html( title => "showing residues ".commify_number($abs_window_start).' - '.commify_number($abs_window_end),
                              is_subsection => 1,
                              contents => join ( '',
						 '<span class="sequence">',
						 ( '&gt;',
                                                   $seq->id,
                                                   ":$abs_window_start..$abs_window_end  ",
                                                   "<br />",
                                                   join( "<br />\n", @lines[ $_->start .. $_->end ] ),
                                                  ),
						 '</span>',
					       ),
                             )
       } @windows;


    return info_table_html( 'Matches' => $match_regions,
                            __border      => 0,
                           );

}

sub highlighted_regions {
    my ( $coords, $highlight_description ) = @_;
    return unless $coords && @$coords;

    return
        "Highlighted Regions ($highlight_description)" =>
        join ', ',
        map "$_->[0]-$_->[1]",
        @$coords;
}

# 0-based line number and column number of the given $index in a
# string broken into lines of width $width
sub line_col {
    my ($index,$width) = @_;
    my $line = POSIX::floor( $index/$width  );
    my $col  = POSIX::fmod ( $index, $width );
    return ($line,$col);
}

sub ranges2coords(@) {
    [ map [ $_->start-1, $_->end-1 ], @{$_[0]} ]
}

sub round_to_nearest_line_beginning {
    my ( $base_number, $line_width, $factor ) = @_;
    $base_number--;
    $base_number += $factor*$line_width; #< convert to 0-based for this calculation
    my $lines_before = POSIX::floor( $base_number / $line_width );
    return $lines_before * $line_width + 1;
}

</%once>
