
<%args>
</%args>

<& /util/import_javascript.mas, classes => [ 'jquery', 'jquery.dataTables', 'jquery.dataTables-buttons-min', 'jszip-min', 'buttons.bootstrap-min', 'buttons.html5-min' ],  &>

<p>Filter the sequence metadata by feature, start, and end position and optionally by the sequence metadata type and/or protocol.</p>

<br />
<a id="sequence_metadata_anchor"></a>

<!-- START QUERY SECTION -->
<div id="sequence_metadata_section_query">

    <form class="form-horizontal" id="sequence_metadata_filter_form" name="sequence_metadata_filter_form">

        <h4>Query Range</h4>
        
        <!-- Feature -->
        <div class="form-group">
            <label class="col-sm-2 control-label">Feature: </label>
            <div class="col-sm-10">
                <select class="form-control" id="sequence_metadata_filter_feature" disabled>
                    <option value="">Loading...</option>
                </select>
            </div>
        </div>

        <!-- Start / End -->
        <div class="form-group">
            <label class="col-sm-2 control-label">Start: </label>
            <div class="col-sm-4">
                <input class="form-control" id="sequence_metadata_filter_start" type="text" value="">
            </div>
            <label class="col-sm-2 control-label">End: </label>
            <div class="col-sm-4">
                <input class="form-control" id="sequence_metadata_filter_end" type="text" value="">
            </div>
        </div>

        <h4>Date Type &amp; Protocol</h4>

        <!-- Data Type -->
        <div class="form-group">
            <label class="col-sm-2 control-label">Type: </label>
            <div class="col-sm-10">
                <select class="form-control" id="sequence_metadata_filter_type" multiple disabled>
                    <option value="">Loading...</option>
                </select>
            </div>
        </div>
        <div class="col-sm-2"></div>
        <div class="col-sm-10">
            <p><a id="sequence_metadata_filter_type_info_btn" href="#"><span class="glyphicon glyphicon-question-sign"></span>&nbsp;Data Type Info</a></p>
            <div id="sequence_metadata_filter_type_info" class="" style="display:none">
                <p>Loading...</p>
            </div>
        </div>
        <br /><br />

        <!-- Protocol -->
        <div class="form-group">
            <label class="col-sm-2 control-label">Protocol: </label>
            <div class="col-sm-10">
                <select class="form-control" id="sequence_metadata_filter_protocol" multiple disabled>
                    <option value="">Loading...</option>
                </select>
            </div>
        </div>
        <div class="col-sm-2"></div>
        <div class="col-sm-10">
            <p><a id="sequence_metadata_filter_protocol_info_btn" href="#"><span class="glyphicon glyphicon-question-sign"></span>&nbsp;Protocol Info</a></p>
            <div id="sequence_metadata_filter_protocol_info" class="" style="display:none">
                <p>Loading...</p>
            </div>
        </div>

        <br /><br /><br />

        <&| /page/info_section.mas, title=>'Advanced Search', subtitle=>'Filter by attribute values', collapsible=>1, collapsed=>1 &>

            <p>Return only sequence metadata features that have attribute values that match the added comparisons.  If more than one attribute 
            filter is added, the sequence metadata feature must match all of the filters.</p>

            <br />

            <!-- Score Min / Max -->
            <div class="form-group">
                <label class="col-sm-2 control-label">Score: </label>
                <div class="col-sm-3">
                    <label class="control-label">Protocol</label><br />
                    <select class="form-control" id="sequence_metadata_filter_score_protocol" disabled>
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="col-sm-3">
                    <label class="control-label">Comparison</label><br />
                    <select class="form-control" id="sequence_metadata_filter_score_comparison">
                        <option value="eq">Equal</option>
                        <option value="lte">Less Than or Equal</option>
                        <option value="lt">Less Than</option>
                        <option value="gte">Greater Than or Equal</option>
                        <option value="gt">Greater Than</option>
                    </select>
                </div>
                <div class="col-sm-3">
                    <label class="control-label">Value</label><br />
                    <input class="form-control" id="sequence_metadata_filter_score_value" type="text" value="">
                </div>
                <div class="col-sm-1">
                    <br />
                    <button id="sequence_metadata_filter_score_add" class="btn btn-info">Add</button>
                </div>
            </div>
            <br /><br />

            <!-- Attribute Value -->
            <div class="form-group">
                <label class="col-sm-2 control-label">Attribute: </label>
                <div class="col-sm-3">
                    <label class="control-label">Protocol</label><br />
                    <select class="form-control" id="sequence_metadata_filter_attribute_protocol" disabled>
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="col-sm-2">
                    <label class="control-label">Key</label><br />
                    <select class="form-control" id="sequence_metadata_filter_attribute_key" disabled>
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="col-sm-2">
                    <label class="control-label">Comparison</label><br />
                    <select class="form-control" id="sequence_metadata_filter_attribute_comparison">
                        <option value="con">Contains</option>
                        <option value="eq">Equal</option>
                        <option value="lte">Less Than or Equal</option>
                        <option value="lt">Less Than</option>
                        <option value="gte">Greater Than or Equal</option>
                        <option value="gt">Greater Than</option>
                    </select>
                </div>
                <div class="col-sm-2">
                    <label class="control-label">Value</label><br />
                    <input class="form-control" id="sequence_metadata_filter_attribute_value" type="text" value="">
                </div>
                <div class="col-sm-1">
                    <br />
                    <button id="sequence_metadata_filter_attribute_add" class="btn btn-info">Add</button>
                </div>
            </div>
            <br />

            <!-- Attribute Table -->
            <div>
                <p><strong>Attribute Filters:</strong></p>
                <table id="sequence_metadata_filter_attributes_table" class="table table-striped table-hover">
                    <tr>
                        <th>Protocol</th>
                        <th>Attribute</th>
                        <th>Comparison</th>
                        <th>Value</th>
                        <th></th>
                    </tr>
                </table>
            </div>

        </&>

        <br /><br /><br />
        

        <!-- QUERY -->
        <div class="center">
            <button id="sequence_metadata_filter_query" class="btn btn-primary btn-block" style="max-width: 400px; margin: auto">Query</button>
        </div>
        <br /><br /><br />


    </form>

    <br />

    <!-- Error Message -->
    <div id="sequence_metadata_filter_error" class="alert alert-danger" role="alert" style="display:none"></div>

    <br />

</div>
<!-- END QUERY SECTION -->


<!-- START RESULTS SECTION -->
<div id="sequence_metadata_section_results" style="display: none">

    <!-- Query Results -->
    <table id="sequence_metadata_filter_results" class="display"></table>

    <br /><br />

    <!-- Return -->
    <div class="center">
        <button id="sequence_metadata_filter_return" class="btn btn-primary btn-block" style="max-width: 400px; margin: auto">
            <span class="glyphicon glyphicon-chevron-left">&nbsp;</span>Back to Query
        </button>
    </div>

    <br /><br />

</div>


<!-- MARKER SEARCH GENOTYPE PROTOCOL SELECTION -->
<div class="modal fade" id="sequence_metadata_genotype_protocol_dialog" name="sequence_metadata_genotype_protocol_dialog" tabindex="-1" role="dialog" aria-labelledby="DeleteModelDataDialog">
    <div class="modal-dialog " role="document">
        <div class="modal-content">
            <div class="modal-header" style="text-align: center">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                <h4 class="modal-title" id="DeleteModelDataDialog">Select Genotype Protocol(s)</h4>
            </div>
            <div class="modal-body">
                <div class="container-fluid">
                    <h4>Marker Search</h4>

                    <p>You can search for markers located within the range of a sequence metadata feature. Here you can choose which genotype protocols to 
                    include in that search.  NOTE: Including more genotype protocols increases the amount of time to perform the marker search.</p>

                    <br />

                    <!-- Genotype Protocols -->
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Genotype Protocol(s): </label>
                        <div class="col-sm-10">
                            <select class="form-control" id="sequence_metadata_filter_genoproto" size="10" multiple disabled>
                                <option value="">Loading...</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="close_delete_model_dialog" type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" name="sequence_metadata_genotype_protocol_dialog_update" id="sequence_metadata_genotype_protocol_dialog_update">Set Genotype Protocol(s)</button>
            </div>
        </div>
    </div>
</div>



<!-- JBROWSE CONFIGURATION -->
<!-- OVERWRITE THIS FILE IN THE INSTANCE-SPECIFIC MASON REPO TO CONFIGURE -->
<& /tools/sequence_metadata/jbrowse_config_sequence_metadata.mas &>


<script type="text/javascript">

var features = [];                          // List of sequence metadata features fetched from the database
var data_types = [];                        // List of sequence metadata data types fetched from the database
var protocols = [];                         // List of existing sequence metadata protocols fetched from the database
var attribute_filter_count = 0;             // Current count of attribute filters added by user
var genotype_protocols = [];                // List of genotype protocols fetched from the database
var genotype_protocols_selected;            // List of user selected genotype protocols for the marker search
var markers;                                // Object of queried markers from the database for specific ranges

jQuery(document).ready(function() {

    // Get the filter features, types, and protocols
    get_features();
    get_types();
    get_protocols();
    get_genotype_protocols();


    //
    // CLICK AND CHANGE LISTENERS
    //

    // Toggle info boxes
    jQuery('#sequence_metadata_filter_type_info_btn').click(function() {
        jQuery('#sequence_metadata_filter_type_info').toggle();
        return false;
    });
    jQuery('#sequence_metadata_filter_protocol_info_btn').click(function() {
        jQuery('#sequence_metadata_filter_protocol_info').toggle();
        return false;
    });

    // Type and Protocol Change Listeners
    jQuery('#sequence_metadata_filter_type').change(set_protocols).change(set_attribute_protocols);
    jQuery('#sequence_metadata_filter_protocol').change(set_types).change(set_attribute_protocols);

    // Attribute Protocol Listener
    jQuery('#sequence_metadata_filter_attribute_protocol').change(set_attribute_keys);

    // Add Score / Attribute Buttons
    jQuery('#sequence_metadata_filter_score_add').click(function() { add_attribute_filter('score'); return false });
    jQuery('#sequence_metadata_filter_attribute_add').click(function() { add_attribute_filter('attribute'); return false });

    // Query Data
    jQuery('#sequence_metadata_filter_query').click(query);

    // Return to Query
    jQuery('#sequence_metadata_filter_return').click(toggle_sections);

    // Setup/Start Marker Search
    jQuery('#sequence_metadata_filter_results').on('click', '.sequence_metadata_genotype_protocol_selection_button', setupMarkerSearch);
    jQuery('#sequence_metadata_genotype_protocol_dialog_update').click(updateMarkerSearchGenotypeProtocols);
    jQuery('#sequence_metadata_filter_results').on('click', '.sequence_metadata_marker_search_button', startMarkerSearch);


    //
    // DATATABLES SETUP
    //

    // Set DataTables Buttons
    let DT_BUTTONS = [
        {
            extend: 'excelHtml5',
            title: 'sequence_metadata_results',
            exportOptions: {
                orthogonal: 'export'
            }
        },
        {
            extend: 'csvHtml5',
            title: 'sequence_metadata_results',
            exportOptions: {
                orthogonal: 'export'
            }
        },
        {
            text: 'JSON',
            action: function() {
                download(getQueryURL('JSON'), "sequence_metadata.json");
            }
        },
        {
            text: 'GA4GH',
            action: function() {
                download(getQueryURL('GA4GH'), "sequence_metadata_ga4gh.json");
            }
        },
        {
            text: 'GFF',
            action: function ( e, dt, button, config ) {
                download(getQueryURL("gff"), "sequence_metadata.gff");
            }
        }
    ];
    if ( JBROWSE_CONFIG_SEQUENCE_METADATA && JBROWSE_CONFIG_SEQUENCE_METADATA.enabled ) {
        DT_BUTTONS.push({
            text: "<span class='glyphicon glyphicon-new-window'></span>&nbsp;JBrowse",
            action: function() {
                window.open(getJBrowseURL(JBROWSE_CONFIG_SEQUENCE_METADATA), '_blank');
            }
        });
    }

    // Init DataTable
    jQuery('#sequence_metadata_filter_results').DataTable({
        dom: 'Bfrtip',
        autoWidth: false,
        data: [],
        columns: [
            { title: "Protocol", data: "nd_protocol_name" },
            { title: "Feature", data: "feature_name" },
            { title: "Start", data: "start" },
            { title: "End", data: "end" },
            { title: "Markers", data: renderMarkersColumn },
            { title: "Score", data: "score" },
            { title: "Attributes", data: "attributes", render: renderAttributesColumn }
        ],
        buttons: DT_BUTTONS
    });

    // Update the Marker Search display when the table is redrawn (on page change, etc...)
    jQuery('#sequence_metadata_filter_results').DataTable().on('draw.dt', function() {
        updateMarkerColumn();
    });

});


//
// DATABASE QUERIES AND RESPONSE HANDLERS
//

/**
 * Get the features associated with stored sequence metadata
 * - populate the options for the feature select box
 */
function get_features() {
    jQuery.ajax({
        type: 'GET',
        dataType: 'json',
        url: '/ajax/sequence_metadata/features',
        success: function(data) {
            features = data.features;
            if ( data && data.features ) {
                let options = "";
                for ( let i = 0; i < data.features.length; i++ ) {
                    let f_id = data.features[i].feature_id;
                    let f_name = data.features[i].feature_name;
                    let o_name = data.features[i].organism_name;
                    let f_label = f_name + " (" + o_name + ")";
                    options += "<option value='" + f_id + "'>" + f_label + "</option>";
                }
                jQuery('#sequence_metadata_filter_feature').html(options);
                jQuery('#sequence_metadata_filter_feature').prop('disabled', false);
            }
            else {
                alert("ERROR: Could not load features!");
            }
        },
        error: function() {
         alert("ERROR: Could not load features");
        }
    });
}

/**
 * Get the types associated with stored sequence metadata
 * - populate the options for the type select box
 */
function get_types() {
    jQuery.ajax({
        type: 'GET',
        dataType: 'json',
        url: '/ajax/sequence_metadata/types',
        success: function(data) {
            if ( data && data.types ) {
                data_types = data.types;
                
                // Set Select Options
                set_types();

                // Build Info Table
                let info = "<table class='table table-striped'><thead><tr><th>Data Type</th><th>Definition</th></tr></thead>";
                info += "<tbody>";
                for ( let i = 0; i < data.types.length; i++ ) {
                    info += "<tr><td>" + data.types[i].type_name + "</td><td>" + data.types[i].type_definition + "</td></tr>";
                }
                info += "</tbody>";
                info += "</table>";
                jQuery('#sequence_metadata_filter_type_info').html(info);

            }
            else {
                alert("ERROR: Could not load types!");
            }
        },
        error: function() {
         alert("ERROR: Could not load types");
        }
    });
}

/**
 * Set the options for the Data Types select box
 */
function set_types() {
    let sel_types = jQuery('#sequence_metadata_filter_type').val();
    let sel_protocols = jQuery('#sequence_metadata_filter_protocol').val();

    let options = "";
    for ( let i = 0; i < data_types.length; i++ ) {
        let t_id = data_types[i].type_id;
        let t_name = data_types[i].type_name;

        // Reselect previosuly selected items
        let selected = false;
        if ( sel_types ) {
            for ( let j = 0; j < sel_types.length; j++ ) {
                if ( parseInt(sel_types[j]) === parseInt(t_id) ) {
                    selected = true;
                }
            }
        }

        // Disable data types based on selected protocols
        let disabled = false;
        if ( sel_protocols && sel_protocols.length > 0 ) {
            disabled = true;
            for ( let j = 0; j < protocols.length; j++ ) {
                for ( let k = 0; k < sel_protocols.length; k++ ) {
                    if ( parseInt(protocols[j].nd_protocol_id) === parseInt(sel_protocols[k]) ) {
                        if ( parseInt(protocols[j].nd_protocol_properties.sequence_metadata_type_id) === parseInt(t_id) ) {
                            disabled = false;
                        }
                    }
                }
            }
        }
        let d = disabled ? 'disabled' : '';
        let s = disabled ? '' : selected ? 'selected' : '';
        options += "<option value='" + t_id + "' " + d + " " + s + ">" + t_name + "</option>";
    }

    jQuery('#sequence_metadata_filter_type').html(options);
    jQuery('#sequence_metadata_filter_type').prop('disabled', false);
}

/**
 * Get the protocols associated with stored sequence metadata
 * - populate the options for the protocol select box
 */
function get_protocols() {
    jQuery.ajax({
        type: 'GET',
        dataType: 'json',
        url: '/ajax/sequence_metadata/protocols',
        success: function(data) {
            if ( data && data.protocols ) {
                protocols = data.protocols;

                // Set Select Options
                set_protocols();
                set_attribute_protocols();

                // Build Info Table
                let info = "<table class='table table-striped'><thead><tr><th>Protocol</th><th>Description</th><th>Properties</th></tr></thead>";
                info += "<tbody>";
                for ( let i = 0; i < data.protocols.length; i++ ) {
                    let props = "<strong>Data Type:</strong>&nbsp;" + data.protocols[i].nd_protocol_properties.sequence_metadata_type + "<br />";
                    props += "<strong>Reference Genome:</strong>&nbsp;" + data.protocols[i].nd_protocol_properties.reference_genome + "<br />";
                    props += "<strong>Score:</strong>&nbsp;" + data.protocols[i].nd_protocol_properties.score_description + "<br />";
                    props += "<strong>Attributes:</strong><br />";
                    let attributes = [];
                    var keys = Object.keys(data.protocols[i].nd_protocol_properties.attribute_descriptions);
                    keys.sort();
                    for ( let j = 0; j < keys.length; j++ ) {
                        let key = keys[j];
                        let description = data.protocols[i].nd_protocol_properties.attribute_descriptions[key];
                        attributes.push("&nbsp;&nbsp;<strong>" + key + ":</strong>&nbsp;" + description);
                    }
                    props += attributes.join('<br />');

                    info += "<tr>";
                    info += "<td>" + data.protocols[i].nd_protocol_name + "</td>";
                    info += "<td>" + data.protocols[i].nd_protocol_description + "</td>";
                    info += "<td>" + props + "</td>";
                    info += "</tr>";
                }
                info += "</tbody>";
                info += "</table>";
                jQuery('#sequence_metadata_filter_protocol_info').html(info);

            }
            else {
                alert("ERROR: Could not load protocols!");
            }
        },
        error: function() {
         alert("ERROR: Could not load protocols");
        }
    });
}

/**
 * Set the options for the Protocol select box
 */
function set_protocols() {
    let sel_protocols = jQuery('#sequence_metadata_filter_protocol').val();
    let sel_types = jQuery('#sequence_metadata_filter_type').val();

    let options = "";
    for ( let i = 0; i < protocols.length; i++ ) {
        let p_id = protocols[i].nd_protocol_id;
        let p_name = protocols[i].nd_protocol_name;
        let p_type_id = protocols[i].nd_protocol_properties.sequence_metadata_type_id;
        
        // Reselect previosuly selected items
        let selected = false;
        if ( sel_protocols ) {
            for ( let j = 0; j < sel_protocols.length; j++ ) {
                if ( parseInt(sel_protocols[j]) === parseInt(p_id) ) {
                    selected = true;
                }
            }
        }

        // Disable protocols based on selected data types
        let disabled = false;
        if ( sel_types && sel_types.length > 0 ) {
            disabled = true;
            for ( let j = 0; j < data_types.length; j++ ) {
                for ( let k = 0; k < sel_types.length; k++ ) {
                    if ( parseInt(data_types[j].type_id) === parseInt(sel_types[k]) ) {
                        if ( parseInt(data_types[j].type_id) === parseInt(p_type_id) ) {
                            disabled = false;
                        }
                    }
                }
            }
        }
        let d = disabled ? 'disabled' : '';
        let s = disabled ? '' : selected ? 'selected' : '';
        options += "<option value='" + p_id + "' " + d + " " + s + ">" + p_name + "</option>";
    }

    // Set protocol selection options
    jQuery('#sequence_metadata_filter_protocol').html(options);
    jQuery('#sequence_metadata_filter_protocol').prop('disabled', false);
}


/**
 * Get the genotype protocols from the database
 * - populate the options for the genotype protocol select box
 */
function get_genotype_protocols() {
    jQuery.ajax({
        type: 'GET',
        dataType: 'json',
        url: '/ajax/sequence_metadata/genotype_protocols',
        success: function(data) {
            if ( data && data.genotype_protocols ) {
                data.genotype_protocols.sort((a, b) => (a.protocol_name > b.protocol_name) ? 1 : -1)
                genotype_protocols = data.genotype_protocols;
                set_genotype_protocols();
            }
        },
        error: function() {
            alert("ERROR: Could not load genotype protocols");
        }
    });
}

/**
 * Set the options for the genotype protocols select box
 */
function set_genotype_protocols() {
    let options = "";

    // Parse the genotype protocols into options
    let parsed = {};
    for ( let i = 0; i < genotype_protocols.length; i++ ) {
        let id = genotype_protocols[i].protocol_id;
        let name = genotype_protocols[i].protocol_name;
        let species = genotype_protocols[i].species_name;
        let markers = genotype_protocols[i].marker_count;
        if ( !parsed.hasOwnProperty(species) ) {
            parsed[species] = [];
        }
        let text = name + " (" + markers + " markers)";
        let option = "<option value='" + id + "'>" + text + "</option>";
        parsed[species].push(option);
    }

    // Group the options by species
    for (let species in parsed) {
        if ( parsed.hasOwnProperty(species) ) {
            options += "<optgroup label='" + species + "'>";
            let items = parsed[species];
            for ( let i = 0; i < items.length; i++ ) {
                options += items[i];
            }
            options += "</optgroup>";
        }
    }

    jQuery("#sequence_metadata_filter_genoproto").html(options);
    jQuery("#sequence_metadata_filter_genoproto").prop('disabled', false);
}

/**
 * Set the protocol lists for the score and attribute select menus
 */
function set_attribute_protocols() {
    let sel_protocols = jQuery('#sequence_metadata_filter_protocol').val();
    let sel_types = jQuery('#sequence_metadata_filter_type').val();

    let options = "";
    for ( let i = 0; i < protocols.length; i++ ) {
        let p_id = protocols[i].nd_protocol_id;
        let p_name = protocols[i].nd_protocol_name;
        let p_type_id = protocols[i].nd_protocol_properties.sequence_metadata_type_id;

        // Only enable selected protocols or selected data types
        let enabled = true;
        if ( sel_protocols ) {
            enabled = false;
            for ( let j = 0; j < sel_protocols.length; j++ ) {
                if ( parseInt(sel_protocols[j]) === parseInt(p_id) ) {
                    enabled = true;
                }
            }
        }
        else if ( sel_types ) {
            enabled = false;
            for ( let j = 0; j < sel_types.length; j++ ) {
                if ( parseInt(sel_types[j]) === parseInt(p_type_id) ) {
                    enabled = true;
                }
            }
        }

        let d = !enabled ? 'disabled' : '';
        options += "<option value='" + p_id + "' " + d + ">" + p_name + "</option>";
    }

    // Set protocol selection options
    jQuery('#sequence_metadata_filter_score_protocol').html(options);
    jQuery('#sequence_metadata_filter_score_protocol').prop('disabled', false);
    jQuery('#sequence_metadata_filter_attribute_protocol').html(options);
    jQuery('#sequence_metadata_filter_attribute_protocol').prop('disabled', false);

    // Update the attribute keys
    set_attribute_keys();
}


/**
 * Set the attribute keys for the currently selected attribute protocol
 */
function set_attribute_keys() {
    let sel_attribute_protocol = jQuery('#sequence_metadata_filter_attribute_protocol').val();
    
    let options = "";
    for ( let i = 0; i < protocols.length; i++ ) {
        if ( parseInt(sel_attribute_protocol) === parseInt(protocols[i].nd_protocol_id) ) {
            let attrs = Object.keys(protocols[i].nd_protocol_properties.attribute_descriptions);
            for ( let j = 0; j < attrs.length; j++ ) {
                options += "<option val='" + attrs[j] + "'>" + attrs[j] + "</option>";
            }
        }
    }

    jQuery('#sequence_metadata_filter_attribute_key').html(options);
    jQuery('#sequence_metadata_filter_attribute_key').prop('disabled', false);
}


/**
 * Add the specified attribute to the list of included attribute filters
 * @param {String} type Attribute type ('score' or 'attribute')
 */
function add_attribute_filter(type) {
    let protocol = jQuery('#sequence_metadata_filter_' + type + '_protocol').val();
    let protocol_name = jQuery('#sequence_metadata_filter_' + type + '_protocol option:selected').text();
    let attribute = type === 'score' ? 'score' : jQuery('#sequence_metadata_filter_attribute_key').val();
    let comp = jQuery('#sequence_metadata_filter_' + type + '_comparison').val();
    let comp_name = jQuery('#sequence_metadata_filter_' + type + '_comparison option:selected').text();
    let value = jQuery('#sequence_metadata_filter_' + type + '_value').val();
    let attribute_param = [attribute, protocol, comp, value].join('|');

    if ( value !== '' ) {
        attribute_filter_count++;
        let html = "<tr id='sequence_metadata_filter_attributes_table_row_" + attribute_filter_count + "'>";
        html += "<td>" + protocol_name + "</td>";
        html += "<td>" + attribute + "</td>";
        html += "<td>" + comp_name + "</td>";
        html += "<td>" + value + "</td>";
        html += "<td style='text-align: right'>";
        html += "<button id='sequence_metadata_filter_attributes_table_remove_" + attribute_filter_count + "' data-row='" + attribute_filter_count + "' class='btn btn-danger btn-xs'><span class='glyphicon glyphicon-remove'></span></button>";
        html += "<input type='hidden' name='sequence_metadata_filter_attribute_" + attribute_filter_count + "' id='sequence_metadata_filter_attribute_" + attribute_filter_count + "' value='" + attribute_param + "'>";
        html += "</td>";
        html += "</tr>";

        jQuery('#sequence_metadata_filter_' + type + '_value').val("");
        jQuery('#sequence_metadata_filter_attributes_table').append(html);
        jQuery('#sequence_metadata_filter_attributes_table_remove_' + attribute_filter_count).click(function() {
            let row = jQuery(this).attr('data-row');
            jQuery('#sequence_metadata_filter_attributes_table_row_' + row).remove();
        });
    }
}



//
// QUERY FUNCTIONS
//


/**
 * Build the Query URL using the current filter properties
 * @param {string} [format] Output format (default: JSON)
 * @param {int[]} [nd_protocol_id] Protocol ID to use (instead of selected protocols)
 * @returns {string} relative URL to query endpoint
 */
function getQueryURL(format, nd_protocol_id) {
    let feature_id = jQuery('#sequence_metadata_filter_feature option:selected').val();
    let start = jQuery('#sequence_metadata_filter_start').val();
    let end = jQuery('#sequence_metadata_filter_end').val();
    let type_ids = jQuery('#sequence_metadata_filter_type').val();
    let sel_nd_protocol_ids = jQuery('#sequence_metadata_filter_protocol').val();

    let params = {
        feature_id: feature_id,
        format: format ? format : 'JSON'
    }
    if ( start && start !== '' ) params.start = start;
    if ( end && end !== '' ) params.end = end;
    if ( type_ids && type_ids.length > 0 ) params.type_id = type_ids;
    if ( nd_protocol_id ) {
        params.nd_protocol_id = nd_protocol_id;
    }
    else {
        if ( sel_nd_protocol_ids && sel_nd_protocol_ids.length > 0 ) params.nd_protocol_id = sel_nd_protocol_ids;
    }
    let attributes = [];
    for ( let i = 1; i <= attribute_filter_count; i++ ) {
        let attr = jQuery('#sequence_metadata_filter_attribute_' + i).val();
        if ( attr && attr !== '' ) {
            attributes.push(attr);
        }
    }
    if ( attributes.length > 0 ) params.attribute = attributes.join(',');

    let q = new URLSearchParams(params).toString();
    let url = '/ajax/sequence_metadata/query?' + q;

    return url;
}


/**
 * Perform a sequence metadata query
 * - Required filter params: feature_id, start, end
 * - Optional filter params: type_id, nd_protocol_id
 * - Get the query results and send to handle_query_results to parse
 */
function query() {
    hide_error();
    jQuery('#sequence_metadata_filter_query').html('Querying...');
    jQuery('#sequence_metadata_filter_query').attr('disabled', true);

    jQuery.ajax({
        type: 'GET',
        url: getQueryURL('JSON'),
        dataType: 'json',
        success: handle_query_results,
        error: function() {
            alert("ERROR: Could query database!");
            jQuery('#sequence_metadata_filter_query').html('Query');
            jQuery('#sequence_metadata_filter_query').attr('disabled', false);
        }
    });

    return false;
}


/**
 * Parse the query results (in JSON format)
 * - Update the rows in the DataTable
 * @param {Object} response          JSON response from the query endpoint
 *                 response.error    message of error encountered by server
 *                 response.results array of sequence metadata objects
 */
function handle_query_results(response) {

    // Update DataTable
    let dt = jQuery('#sequence_metadata_filter_results').DataTable();
    dt.clear();
    if ( response && response.error ) {
        display_error(response.error);
    }
    else if ( response && response.results && response.results.length > 0) {
        dt.rows.add(response.results);
        toggle_sections();
    }
    else {
        display_error("No results found - try modifying your filter criteria");
    }
    dt.draw();

    // Reset Markers
    markers = undefined;
    updateMarkerColumn();

    // Reset Query Button
    jQuery('#sequence_metadata_filter_query').html('Query');
    jQuery('#sequence_metadata_filter_query').attr('disabled', false);

}



/**
 * Build a URL to view the seleceted data in jBrowse
 * @params {Object} config JBrowse configuration properties
 * @returns {string} url to jbrowse with remote tracks added
 */
function getJBrowseURL(config) {
    // Get Selected Types
    let sel_types = jQuery('#sequence_metadata_filter_type').val();
    
    // Get Selected Protocols (or all enabled protocols, if none selected)
    let sel_protocols = jQuery('#sequence_metadata_filter_protocol').val();
    if ( !sel_protocols ) {
        sel_protocols = [];
        for ( let i = 0; i < protocols.length; i++ ) {
            if ( sel_types && sel_types.length > 0 ) {
                for ( let j = 0; j < sel_types.length; j++ ) {
                    if ( parseInt(protocols[i].nd_protocol_properties.sequence_metadata_type_id) === parseInt(sel_types[j]) ) {
                        sel_protocols.push(protocols[i].nd_protocol_id);
                    }
                }
            }
            else {
                sel_protocols.push(protocols[i].nd_protocol_id);
            }
        }
    }

    // Get Selected Protocol names (for track labels)
    let sel_protocol_names = {};
    for ( let i = 0; i < sel_protocols.length; i++ ) {
        for ( let j = 0; j < protocols.length; j++ ) {
            if ( parseInt(sel_protocols[i]) === parseInt(protocols[j].nd_protocol_id) ) {
                sel_protocol_names[sel_protocols[i].toString()] = protocols[j].nd_protocol_name.replaceAll(" ", "&nbsp;");
            }
        }
    }
    
    // Get Selected Feature (for jBrowse chromosome name)
    let sel_feature = jQuery('#sequence_metadata_filter_feature').val();
    let sel_feature_name = '';
    for ( let i = 0; i < features.length; i++ ) {
        if ( parseInt(features[i].feature_id) === parseInt(sel_feature) ) {
            sel_feature_name = features[i].feature_name;
        }
    }

    // Get Selected start and end for range
    let start = jQuery('#sequence_metadata_filter_start').val();
    let end = jQuery('#sequence_metadata_filter_end').val();
    let range = '';
    if ( start && start !== '' && end && end !== '' ) {
        range = ":" + start + ".." + end
    }

    // Build JBrowse Stores & Tracks
    let stores = {};
    let tracks = [];
    for ( let i = 0; i < sel_protocols.length; i++ ) {
        stores["url" + i] = {
            type: "JBrowse/Store/SeqFeature/GFF3",
            urlTemplate: window.location.protocol + "//" + window.location.host + getQueryURL("gff", sel_protocols[i])
        }
        tracks.push({
            label: sel_protocol_names[sel_protocols[i].toString()],
            type: "JBrowse/View/Track/CanvasFeatures",
            store: "url" + i
        });            
    }

    // Build URL
    let base_url = config.base_url;
    let params = {
        data: config.data_dir,
        loc: config.location_name(sel_feature_name) + range,
        tracks: config.tracks.concat(Object.values(sel_protocol_names)).join(','),
        addStores: JSON.stringify(stores),
        addTracks: JSON.stringify(tracks)
    }
    let q = new URLSearchParams(params).toString();
    let url = base_url + '?' + q;

    return url;
}



//
// MARKER SEARCH FUNCTIONS
//


/**
 * Setup the marker search by having the user select the genotype protocols to use
 */
function setupMarkerSearch() {
    jQuery('#sequence_metadata_genotype_protocol_dialog').modal('show');
    return false;
}


/**
 * Update the list of genotype protocols selected by the user
 */
function updateMarkerSearchGenotypeProtocols() {
    genotype_protocols_selected = jQuery("#sequence_metadata_filter_genoproto").val();
    markers = undefined;
    updateMarkerColumn();
    jQuery('#sequence_metadata_genotype_protocol_dialog').modal('hide');
}


/**
 * Perform a marker search on the selected row's feature and sequence range, 
 * optionally filtered by the user's selected genotype protocols
 */
function startMarkerSearch() {
    let parent = jQuery(this).parents(".sequence_metadata_marker_search_markers");
    let feature_id = parent.data("feature-id");
    let start = parent.data("start");
    let end = parent.data("end");
    let key = [feature_id, start, end].join("-");

    // Update the DataTables
    if ( !markers ) markers = {};
    markers[key] = "Searching...";
    updateMarkerColumn();

    // Query the Database for Markers
    jQuery.ajax({
        type: 'GET',
        url: '/ajax/sequence_metadata/markers',
        data: {
            feature_id: feature_id,
            start: start,
            end: end,
            nd_protocol_id: genotype_protocols_selected ? genotype_protocols_selected.join(',') : undefined
        },
        dataType: 'json',
        success: function(data) {

            // Save the markers and update the DataTables
            if ( data && data.results ) {
                markers[key] = data.results;
                updateMarkerColumn();
            }

        },
        error: function() {
            alert("ERROR: Could not perform marker search");
        }
    });

    return false;
}

/**
 * Update the contents of the marker column in the results table
 */
function updateMarkerColumn() {

    // Update the markers (add search button or marker links)
    // only if genotype protocol(s) has been selected
    if ( genotype_protocols_selected ) {
        jQuery('.sequence_metadata_marker_search_markers').each(function() {
            let feature_id = jQuery(this).data("feature-id");
            let start = jQuery(this).data("start");
            let end = jQuery(this).data("end");
            let key = [feature_id, start, end].join("-");
            
            let marker_html = "";
            if ( markers && markers.hasOwnProperty(key) ) {
                let value = markers[key];
                if ( typeof value === 'string' ) {
                    marker_html = "<p>" + value + "</p>";
                }
                else if ( Array.isArray(value) ) {
                    if ( value.length === 0 ) {
                        marker_html = "<p>No Markers Found</p>";
                    }
                    else {
                        for ( let i = 0; i < value.length; i++ ) {
                            marker_html += "<strong><a href='/markerGeno/" + value[i].marker_name + "/details'>" + value[i].marker_name + "</a></strong> "
                            marker_html += "(<a href='/breeders_toolbox/protocol/" + value[i].nd_protocol_id + "'>" + value[i].nd_protocol_name + "</a>)<br />";
                        }
                        marker_html += "<br />";
                    }
                }
            }
            else {
                marker_html = "<p><a class='sequence_metadata_marker_search_button' href='#'>Search for Markers</a></p>";
            }
            jQuery('.sequence_metadata_marker_search_markers_' + key).html(marker_html);
        });
    }

    // Update the protocol buttons for all rows
    let protocol_label = "";
    if ( !genotype_protocols_selected ) {
        protocol_label = "Select Genotype Protocols";
    }
    else {
        protocol_label = "Update Genotype Protocols";
    }
    let protocol_html = "<a class='sequence_metadata_genotype_protocol_selection_button' href='#'>" + protocol_label + "</a>";
    jQuery('.sequence_metadata_marker_search_protocols').html(protocol_html);

}



//
// DATA TABLE RENDER FUNCTIONS
//

/**
 * Render the Markers column
 * @param {Object} row The current row's data
 * @param {String} type The display type
 * @returns {String} The text/html to display in the table
 */
function renderMarkersColumn(row, type) {
    let data = "data-feature-id='" + row.feature_id + "' data-start='" + row.start + "' data-end='" + row.end + "'";
    let key = row.feature_id + "-" + row.start + "-" + row.end;
    
    let html = "<div class='sequence_metadata_marker_search'>";
    html += "<div class='sequence_metadata_marker_search_markers sequence_metadata_marker_search_markers_" + key + "' " + data + "></div>";
    html += "<div class='sequence_metadata_marker_search_protocols'></div>";
    html += "</div>";

    return html;
}

/**
 * Render the Attributes column
 * @param data The column's data for the current row
 * @param {String} type The display type
 * @param {Object} row The current row's data
 * @returns {String} The text/html to display in the table
 */
function renderAttributesColumn(data, type, row) {
    let rtn = [];
    let sep = type === 'export' ? ';' : '<br />';
    if ( data ) {
        var keys = Object.keys(data);
        keys.sort();
        for ( var i=0; i<keys.length; ++i ) {
            let key = keys[i];
            let value = data[keys[i]];
            if ( type === 'export' ) {
                rtn.push(key + '=' + value);
            }
            else {
                rtn.push("<strong>" + key + ":</strong>&nbsp;" + value);
            }
        }
    }
    return rtn.join(sep);
} 



//
// HELPER FUNCTIONS
//


/**
 * Toggle the display of the query and results sections
 */
function toggle_sections() {
    jQuery("#sequence_metadata_section_query").toggle();
    jQuery("#sequence_metadata_section_results").toggle();
    let anchor = jQuery('#sequence_metadata_anchor');
    jQuery('html,body').animate({scrollTop: anchor.offset().top-150}, 'fast');
}

/**
 * Display an error message
 * @param {string} message The message to display (undefined to clear the message)
 */
function display_error(message) {
    jQuery('#sequence_metadata_filter_error').html(message ? message : "");
    jQuery('#sequence_metadata_filter_error').css('display', message ? 'block' : 'none');
}

/**
 * Clear and hide the error message alert box
 */
function hide_error() {
    display_error();
}

/**
 * Prompt a download of the specified url with the given file name
 * @param {String} url URL to download
 * @param {String} name Name to give the downloaded file
 */
function download(url, name) {
    var a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

</script>


<style>
    select option:disabled {
        font-weight: 200;
        font-style: italic;
        color: #DCDCDC;
    }
</style>
