<%doc>


</%doc>

<%args>

</%args>

<& '/page/page_title.mas', title => "Graphical Filtering" &>

<& '/util/import_javascript.mas', classes => [ 'jquery', 'jqueryui', 'popup', 'CXGN.List', 'CXGN.Login', 'd3.d3v4Min' ] &>

<div class="row">
  <center class = "col-md-offset-2 col-md-8">
    <form class="tc-form">
      <div class="form-group">
        <label for="trials_list_select">Choose a list of trials:</label>
        <div id="trials_list_select_container">
          <select disabled class="form-control input-sm" id="trials_list_select">
            <option selected="selected">Loading...</option>
          </select
      </div>
      <img hidden id="results-loading-spinner" src="/img/wheel.gif" alt="loading">
    </form>
  </center>
</div>

<div id="filter_div" class="row"></div>
<div id="filtered_results_wrap" class="row dataTables_wrapper">
  <table id="filtered_results" width="100%" class="table table-hover table-striped dataTable no-footer" role="grid" style="width: 100%;"></table>
</div>

<script>
$(document).ready(function(){
  var list = new CXGN.List();
  var select_html = list.listSelect('trials', ['trials'], ' ');
  $('#trials_list_select_container').html(select_html);
  if (d3.select('#trials_list_select').selectAll("option").size()<2){
    d3.select('#trials_list_select').html("<option>No trial lists! (Create one using the wizard.)</option>");
  }
  $("#trials_list_select").change(function(){
    var trial_list_id = $(this).val();
    console.log(trial_list_id);
    $.get('/ajax/trial/accession_trait_csv?trial_list_id='+trial_list_id, function(response) {
        console.log(response);
        var cols = response.data[0];
        var data = response.data
          .slice(1,response.data.length)
          .map(function(row){
            var obj = {};
            for (var i = 0; i < cols.length; i++) {
              if (row[i]==null) return null;
              obj[cols[i]] = row[i];
            }
            return obj;
          })
          .filter(function(d){
            return d!=null;
          });
        rangeTraits = response.traits.results.map(function(d){return d[1];});
        console.log(data);
        window.gfiltering.main("#filter_div","#filtered_results",data,rangeTraits);
    });
  })
});

(function(d3){
  window.gfiltering = {};
  window.gfiltering.main = function(filter_selector,table_selector,data,rangeTraits){
    console.log(data);
    var canv = d3.select(filter_selector);
    var root = new FilterGroup(null,0,"init");
    window.gfiltering.rangeTraits = rangeTraits;
    root.draw(canv.node());
    window.gfiltering.redraw = function(){
      root.updateData(data);
      root.draw();
    }
    window.gfiltering.redraw();
  }

  function Filter(parent,depth,operator){
    //constructor
    this.type = "default";
    this.parent = parent || null;
    this.depth = depth || 0;
    this.operator = operator || "init";
  }
  //static
  Filter.operator_types = [
    [0,"and","filter-operator-and"],
    [1,"or","filter-operator-or"],
    [2,"and not","filter-operator-and-not"],
    [3,"or not","filter-operator-or-not"]
  ];
  Filter.operator_map = d3.map(Filter.operator_types,function(d){return d[1]});
  //prototype
  Filter.prototype.getFilter = function(){
    return null;
  };
  Filter.prototype.updateData = function(data){
    //update the data
  };
  Filter.prototype.draw = function(node){
    //just update th visuals
    if (node) this.node = node;
    if (!this.node) return false;
    this.updateOperator();
  };
  Filter.prototype.updateOperator = function(){
    var f = d3.select(this.node);
    var operatorData = this.operator == "init" ? [] : [this];
    var operator = f.selectAll(".filter-operator[depth = '"+(this.depth)+"']")
      .data(operatorData);
    operator.exit().remove();
    if (operatorData.length>0){
      operator.enter().append("div")
        .classed("filter-operator",true)
        .attr("depth",this.depth)
        .classed(Filter.operator_map.get(this.operator)[2],true)
        .on("click",function(d){
          var preoperator = Filter.operator_map.get(d.operator);
          var newindex = (preoperator[0]+1)%Filter.operator_types.length;
          var newoperator = Filter.operator_types[newindex];
          d3.select(this)
            .classed(preoperator[2],false)
            .classed(newoperator[2],true);
          d.operator = newoperator[1];
          window.gfiltering.redraw();
        });
      }
  };

  function FilterGroup(parent,depth,operator){
    //constructor
    Filter.call(this,parent,depth,operator);
    this.type = "filtergroup";
    this.children = [];
  }
  FilterGroup.prototype = Object.create(Filter.prototype);
  FilterGroup.prototype.constructor = FilterGroup;
  FilterGroup.prototype.getFilter = function(){
    var negate = (this.operator.indexOf("not", this.operator.length - 3) != -1);
    var conjointGs = this.getConjointGroups(true);
    return function(d){
      var result = false;
      var anyFiltered = false;
      for (var i = 0; i < conjointGs.length; i++) {
        var groupval = true;
        var filtered = false;
        //set groupval to false if any conjoint filter is false
        for (var j = 0; j < conjointGs[i].length; j++) {
          if (conjointGs[i][j]!=null){
            filtered = true;
          }
          if (conjointGs[i][j] && !conjointGs[i][j](d)){
            groupval = false;
            break;
          }
        }
        // OR-join the result of each conjoint group
        if (filtered) result = result || groupval;
        anyFiltered = anyFiltered || filtered;
      }
      if (anyFiltered) return negate ? !result : result;
      return true;
    }
  };
  FilterGroup.prototype.updateData = function(data){
    this.data = data;
    var childgroups = this.getConjointGroups();
    var filtergroups = this.getConjointGroups(true);
    for (var i = 0; i < childgroups.length; i++) {
      var group = childgroups[i];
      for (var j = 0; j < group.length; j++) {
        var childData = data;
        for (var k = 0; k < group.length; k++) {
          if (k!=j && filtergroups[i][k]) {
            childData = childData.filter(filtergroups[i][k]);
          }
        }
        group[j].updateData(childData);
      }
    }
  };
  FilterGroup.prototype.draw = function(node){
    Filter.prototype.draw.call(this,node);
    var f = d3.select(this.node);
    var fg = f.selectAll(".filter-wrapper").data([this]);
    var fgenter = fg.enter().append("div")
      .classed("filter-wrapper",true);
    fgenter.append("span")
      .classed("filter-wrapper-children",true);
    var addmenuE = fgenter.append("div")
      .classed("filter-new",true)
      .append("div")
      .classed("filter-new-menu",true);
    addmenuE.append("span")
      .classed("filter-new-text",true)
      .text("Range")
      .on("click",function(d){
        var op = d.children.length==0 ? "init" : "and";
        d.children.push(new FilterRange(d,d.depth+1,op));
        window.gfiltering.redraw();
      });
    addmenuE.append("span")
      .classed("filter-new-text",true)
      .text("Group")
      .on("click",function(d){
        var op = d.children.length==0 ? "init" : "and";
        d.children.push(new FilterGroup(d,d.depth+1,op));
        window.gfiltering.redraw();
      });
    //draw children
    fgenter.merge(fg).select(".filter-wrapper-children")
      .each(function(d){
        var subfilters = d3.select(this)
          .selectAll("[depth = '"+(d.depth+1)+"'].filter-item")
          .data(d.children);
        subfilters.exit().remove();
        subfilters.enter()
          .append("div")
          .classed("filter-item",true)
          .attr("depth",d.depth+1)
        .merge(subfilters)
          .each(function(d){
            d.draw(this);
          })
      })
  }
  FilterGroup.prototype.getConjointGroups = function(returnFilters){
    // returns groups of filters connected by ANDs
    var cjGroups = [[]];
    if (this.children[0]){
      if (returnFilters){
        cjGroups[cjGroups.length-1].push(this.children[0].getFilter());
      } else {
        cjGroups[cjGroups.length-1].push(this.children[0]);
      }
    }
    for (var i = 1; i < this.children.length; i++) {
      var op = this.children[i].operator;
      var disjunct = !op.lastIndexOf("or", 0);
      if (disjunct) cjGroups.push([]);
      if (returnFilters) {
        cjGroups[cjGroups.length-1].push(this.children[i].getFilter());
      } else {
        cjGroups[cjGroups.length-1].push(this.children[i]);
      }
    }
    return cjGroups;
  }

  var frIDer = (function*(){
    var i = 10000;
    while (true) yield i++;
  })();
  function FilterRange(parent,depth,operator){
    //constructor
    this.frID = frIDer.next().value;
    Filter.call(this,parent,depth,operator);
    this.type = "filterrange";
    this.brushRange = [null,null];
    this.centerVal = 0;
    this.centerID = 0;
    this.b_width = this.width - (this.margin.left+this.margin.right);
    this.b_height = this.height - (this.margin.top+this.margin.bottom);
    this.filterTrait = null;
    this.valueAccessor = null;
    this.data = [];
  }
  FilterRange.prototype = Object.create(Filter.prototype);
  FilterRange.prototype.constructor = FilterRange;
  //FilterRange layout
  $.extend(FilterRange.prototype,{
    ttime:200,
    bin_count_range:[10,10],
    width:300,
    height:150,
    margin:{top:4,bottom:20,left:4,right:4}
  });
  FilterRange.prototype.getFilter = function(){
    if (this.brushRange[0]==null) return null;
    var hist = this;
    var negate = (this.operator.indexOf("not", this.operator.length - 3) != -1);
    // if (this.brushRange[0]==null) return function(){return !negate;};
    return function(d){
      var val = hist.valueAccessor(d);
      var res = (val >= hist.brushRange[0] && val <= hist.brushRange[1]);
      return (negate? !res : res);
    };
  }
  FilterRange.prototype.updateData = function(data){
    this.data = data;
  };
  FilterRange.prototype.refreshSelect = function(){
    var select = d3.select(this.select);
    this.selectableTraits = ["Select a Trait..."].concat(window.gfiltering.rangeTraits);
    var ops = select.selectAll("option").data(this.selectableTraits);
    ops.exit().remove();
    var opsE = ops.enter().append("option");
    opsE.filter(function(d,i){return !i;})
      .attr("selected",true);
    opsE.merge(ops)
      .text(function(d,i){return d;})
      .property("value",function(d,i){return d;})
      .filter(function(d,i){return !i;})
      .property("value",null)
      .attr("disabled",true);
  };
  FilterRange.prototype.draw = function(node){
    Filter.prototype.draw.call(this,node);
    var panel = d3.select(this.node).selectAll(".filter-panel")
      .data([this]);
    if (!panel.enter().empty()){
      var pe = panel.enter().append('div')
        .classed("filter-panel-range filter-panel panel panel-default",true);
      var heading = pe.append('div')
        .classed("panel-heading",true);
      var body = pe.append('div')
        .classed("panel-body",true);
      var select = heading.append("select")
        .on("change",function(){
          var fr = d3.select(this).datum();
          fr.filterTrait = $(this).val();
          fr.valueAccessor = function(d){
            return parseFloat(d[fr.filterTrait]);
          };
          window.gfiltering.redraw();
        });
      this.select = select.node();
      panel = pe.merge(panel);
      this.panel = panel.node();
    }
    this.refreshSelect();
    if (this.valueAccessor && this.filterTrait){
      var svg = panel.select(".panel-body").selectAll("svg").data([this]);
      if (!svg.enter().empty()){
        var svgE = svg.enter().append("svg");
        svgE.attr("width","100%")
          .attr("shape-rendering","geometricPrecision")
          .attr("viewBox","0 0 "+this.width+" "+this.height);
        svgE.append("rect")
          .attr("x",this.margin.left)
          .attr("y",this.margin.top)
          .attr("width",this.b_width)
          .attr("height",this.b_height)
          .attr("fill","none")
          .attr("stroke","#eee");
        this.x = d3.scaleLinear()
          .range([0, this.b_width-1]);
        this.y = d3.scaleLinear()
          .range([this.b_height, 11]);
        this.xAxis = d3.axisBottom(this.x);
        svgE.append("g")
          .attr("transform","translate("+this.margin.left+","+(this.height-this.margin.bottom)+")")
          .classed("x-axis",true);
        var plotgroup = svgE.append("g")
          .attr("transform","translate("+this.margin.left+","+this.margin.top+")");
        this.plotgroup = plotgroup.node();
        var brushfunc = this.getBrushCallback();
        this.brush = d3.brushX()
          .extent([[this.margin.left,this.margin.top],[this.margin.left+this.b_width,this.margin.top+this.b_height]])
          .on("end",brushfunc)
          .on("brush",brushfunc);
        svgE.append("g")
          .classed("brush",true)
          .call(this.brush);
        this.svg = svgE.node();
      }
      this.drawHistogram();
    } else {
      panel.selectAll("svg").remove();
    }
  };

  FilterRange.prototype.drawHistogram = function(){

    var extent = d3.extent(this.data, this.valueAccessor);
    if (this.data.length<2) extent = [-1,1];
    this.x.domain(extent);
    var thresholds = [];
    var bin_count = d3.thresholdFreedmanDiaconis(this.data.map(this.valueAccessor), extent[0], extent[1]);
    var bin_count = Math.min(Math.max(bin_count,this.bin_count_range[0]),this.bin_count_range[1]);
    for (var i = 0; i < bin_count+1; i++) {
      thresholds.push(extent[0]+((extent[1]-extent[0])*i/bin_count));
    }
    var bins = d3.histogram()
      .domain(this.x.domain())
      .thresholds(thresholds.slice(0,thresholds.length-1))
      .value(this.valueAccessor)(this.data);
    this.y.domain([0, d3.max(bins, function(d) { return d.length; })]);

    //order bins to be ID'd by distance to the centerVal. (sorted by *signed* distance)
    var cvBisector = d3.bisector(function(bin){return d3.mean([bin.x0,bin.x1]);}).left;
    var splitI = cvBisector(bins,this.centerVal);
    var sortedBins = bins.slice(splitI).concat(bins.slice(0,splitI).reverse());

    //give the bins IDs based on position.
    var positiveID = parseInt(this.centerID);
    var negativeID = parseInt(this.centerID)-1;
    for (var i = 0; i < sortedBins.length; i++) {
      var bin = sortedBins[i];
      if (d3.mean([bin.x0,bin.x1])<this.centerVal){
        bin.keyID = negativeID;
        bin.enterleft = true;
        negativeID -= 1;
      } else {
        bin.keyID = positiveID;
        positiveID += 1;
      }
    }
    this.centerVal = sortedBins[0].x0;
    this.centerID = sortedBins[0].keyID;

    var hist = this;
    var bars = d3.select(this.plotgroup).selectAll(".bar")
      .data(sortedBins,function(d,i){
        return hist.name+" "+d.keyID;
      });
    var entered = bars.enter().append("g")
      .attr("class", "bar");
    var bar_height = this.b_height;
    entered.append("rect")
      .attr("fill","#c9c")
      .attr("y", function(d){return hist.y(d.length)})
      .attr("height", function(d) { return bar_height-hist.y(d.length); })
      .attr("width", 0)
      .attr("x", this.b_width)
      .filter(function(d){return d.keyID<hist.centerID})
      .attr("x", 0);
    entered.append("text")
      .attr("text-anchor","middle")
      .attr("font-size",8)
      .attr("fill","#999")
      .attr("opacity",0)
      .attr("y",function(d){return hist.y(d.length)-2})
      .text("")
      .attr("x", this.b_width)
      .filter(function(d){return d.keyID<hist.centerID})
      .attr("x", 0);
    var newBars = entered.merge(bars);
    newBars.select("rect")
      .transition().duration(this.ttime)
      .attr("y", function(d){return hist.y(d.length)})
      .attr("width", this.x(bins[0].x1) - this.x(bins[0].x0) - 1)
      .attr("height", function(d) { return bar_height-hist.y(d.length); })
      .attr("x", function(d){return hist.x(d.x0)+1});
    newBars.select("text")
      .transition().duration(this.ttime)
      .attr("opacity",1)
      .attr("x", function(d){return hist.x((d.x0+d.x1)/2)})
      .attr("y", function(d){return hist.y(d.length)-2})
      .text(function(d){return d.length>0?d.length:""});
    bars.exit().transition().duration(this.ttime).remove();
    bars.exit().select("rect")
      .transition().duration(this.ttime)
      .attr("width", 0)
      .attr("x", this.b_width)
      .filter(function(d){return d.keyID<hist.centerID})
      .attr("x", 0);
    bars.exit().select("text")
        .transition().duration(this.ttime)
        .attr("opacity",0)
        .attr("x", this.b_width)
        .filter(function(d){return d.keyID<hist.centerID})
        .attr("x", 0);

    var inputs = d3.select(this.body)
      .selectAll("input")
      .raise()
      .data([[0,this.brushRange,"from..."],[1,this.brushRange,"...to"]]);
    inputs.enter()
      .append("input")
      .attr("type","number")
      .attr("step","0.1")
      .attr("placeholder",function(d){
        return d[2];
      })
      .on("change",function(d){
        d[1][d[0]] = this.value;
        hist.brushed();
      })
    .merge(inputs)
      .each(function(d){
        this.value = d[1][d[0]];
      });
    var status = d3.select(this.panel)
      .selectAll(".filter-status").raise().data([0]);
    status = status.enter().append("div")
      .classed("filter-status",true)
      .merge(status);

    if (hist.brushRange[0]!==null){
      var total = this.data.length;
      var filtered = this.data.filter(this.getFilter()).length;
      status.text(filtered+"/"+total+" selected.");
      var transition = d3.select(this.svg)
        .select(".brush")
        .transition().duration(this.ttime);
      var brushExtent = this.brushRange
        .map(this.x.copy().clamp(true))
        .map(function(d){return d+hist.margin.left;});
      this.brush.move(transition,brushExtent);
    } else {
      status.text("Select a range.");
    }

    var d = this.x.domain();
    var ticks = [d3.min(d),d3.mean(d),d3.max(d)];
    this.xAxis = d3.axisBottom(this.x)
      .tickValues(ticks)
      .tickFormat(d3.format("1.2"));
    d3.select(this.svg).select(".x-axis")
      .transition()
      .duration(this.ttime)
      .call(this.xAxis);
  };

  FilterRange.prototype.getBrushCallback = function(){
    var hist = this;
    return function(d,i){
      if (d3.event.type!="change" && !d3.event.selection){
        clearTimeout(hist.brush_timeout);
        hist.brushRange = [null,null];
        window.gfiltering.redraw();
      } else if (d3.event.sourceEvent || d3.event.type=="change"){
        clearTimeout(hist.brush_timeout);
        var lastSelectedRange = d3.event.selection;
        hist.brush_timeout = setTimeout(function(){
          if(lastSelectedRange){
            hist.brushRange = lastSelectedRange
            .map(function(d){return d-hist.margin.left;})
            .map(hist.x.invert);
            // .map(d3.format(".2"))
            // .map(parseFloat);
          }
          //if there arent enough items in the selection (2) expand the selection to include the nearest ones.
          if (hist.getFilter()&&hist.data.filter(hist.getFilter()).length<2){
            console.log("adjusted")
            var values = hist.data.map(hist.valueAccessor);
            values.sort(function(a,b){return a-b;});
            var midVal = d3.mean(hist.brushRange);
            var midI = d3.bisect(values.slice(1),midVal);
            hist.brushRange = [values[midI],values[midI+1]];
          }
          window.gfiltering.redraw();
          clearTimeout(hist.brush_timeout)
        },d3.event.type=="end"?0:hist.ttime);
      }
    }
  };
})(d3);

</script>
