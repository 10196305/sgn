


package CXGN::Page::IdentifierEngine;

=head1 NAME

CXGN::Page::IdentifierMonkey - class that can do things with plaintext
  identifier strings used for various pieces of data.

=head1 DESCRIPTION

Things objects of this class can do:
  - given a string, guess the namespace of an identifier
  - given a plaintext identifier and its namespace, return an
      HTML link to its proper information page
  - given a string identifier, parse it into its component parts

=head1 SYNOPSIS

coming soon

=cut

use strict;
use warnings;

our    %urlencode;
use Tie::UrlEncoder;
use Class::MethodMaker
[
 new => [qw/-init new/],
];

#use base qw/Class::Singleton/;

=head1 METHODS

=head2 new

  Usage: my $eng = CXGN::Page::IdentifierEngine->instance;
  Desc : get a CXGN identifier engine
  Ret  : the identifier engine object
  Args : none
  Side Effects: makes a new engine
  Example:

=cut

#new is generated by Class::MethodMaker above

sub init {
  my $self = shift;
  #put your initialization here


}

=head2 guess_namespace

  Usage: my $ns_name = $eng->guess_namespace('SGN-U3223'); #returns 'sgn_u'
  Desc : guess the namespace of a given identifier
  Ret  : the string name of the namespace
  Args : string identifier
  Side Effects: none
  Example:

=head3 Supported Namespaces


=head3 Namespaces Not Yet Supported

  sgn_u   - SGN unigene identifiers 'SGN-U2342'
  sgn_e   - SGN EST identifiers 'SGN-E234223'
  est     - other kinds of EST identifiers 'cLEC-23-A23'
  bac_end - BAC end identifiers 'LE_HBa0123A12_SP6_2342'
  bac     - BAC identifiers
  bac_cu  - old-style Cornell BAC identifiers 'P234A23'
  marker  - marker names.  good luck with this one.  'TG23'

=cut



sub guess_namespace {
    my $self = shift;
    
}

=head2 get_link

  Usage: $eng->get_link('SGN-U22222'); #gives a link to the unigene info page
  Desc : given a plaintext identifier, gives a link to the info page for that
         particular piece of data.  If namespace and page name are not given,
         it guesses the namespace and uses the default info page.
  Ret  :
  Args : ( identifier string, (optional) namespace name, (optional) page name )
  Side Effects: none
  Example:

=head3 Registered Pages

  To Do:
  clone_info   - info page for a genomic clone
  clone_search - search for a genomic clone
  unigene      - info page for a unigene
  est          - info page for an est

=cut

sub get_link {
    my $self = shift;
    my $id = shift;


    my $est_link = "/search/est.pl?request_id=$urlencode{$id}";
    my $marker_link = "/search/markers/markerinfo.pl?name=$urlencode{$id}";
    my $unigene_link = "/search/unigene.pl?unigene_id=$urlencode{$id}";
    my $ncbi_link = "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=$urlencode{$id}";
    my $arabidopsis_link = "http://www.arabidopsis.org/servlets/TairObject?type=locus&name=$urlencode{$id}";
    
    my %id_mapping = ( 
		       "SGN(\\-|\\_)U\\d{5,8}" =>  ($unigene_link, "sgn_unigene"), 
		       "sgn(\\-|\\_)e\\d{5,8}" =>  ($est_link, "sgn_est"),         
		       "[A-Z]{1,2}\\d{1,3}"    =>  ($marker_link, "sgn_rflp_marker"),  
		       "C2\\_At\\dg\\d+"           =>  ($marker_link, "sgn_cosii_marker"), 
		       "At\\dg\\d+(\\.\\d+){0,1}"     =>  ($arabidopsis_link, "tair_locus"),
		       "(tomato|lycopersicon esculentum|solanum lycopersicum)"  => ("/content/sgn_data.pl#Solanumlycopersicum()", "sol_species"),
		       "(potato|solanum tuberosum)" => ("/content/sgn_data.pl#Solanumtuberosum", "sol_species"),
		       "(eggplant|solanum melongena)" => ("/content/sgn_data.pl#Solanummelongena", "sol_species"),
		       "(pepper|capsicum|capsicum annuum)" => ("/content/sgn_data.pl#Capsicumannuum", "sol_species"),
		       "(petunia|petunia hybrida)"              =>  ("/content/sgn_data.pl#petunia", "sol_species"),
		       "(arabidopsis|arabidopsis thaliana|A.\\s+thaliana)" => ("http://www.arabidopsis.org/about/arabidopsis.jsp", "sol_species"),
		       "(coffee|coffea|coffea\\s+arabica|coffea\\s+robusta)" => ("/content/coffee.pl", "sol_species"),
		     );
    
    print STDERR "Finding the link for $id...\n";
    foreach my $pattern (keys(%id_mapping)) { 
	if ($id =~ m/$pattern/i) { 
	    print STDERR "found link for $pattern: $id_mapping{$pattern}\n";
	    return ($id_mapping{$pattern})[0];
	}
    }
}



	



###
1;#do not remove
###



