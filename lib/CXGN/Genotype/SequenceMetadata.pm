package CXGN::Genotype::SequenceMetadata;

=head1 NAME

CXGN::Genotype::SequenceMetadata - used to manage sequence metadata in the featureprop_json table

=head1 USAGE

To preprocess and verify a gff file for the featureprop_json table:
my $smd = CXGN::Genotype::SequenceMetadata->new(bcs_schema => $schema);
my $verification_results = $smd->verify($original_filepath, $processed_filepath);

To store a gff file to the featureprop_json table:
my $smd = CXGN::Genotype::SequenceMetadata->new(bcs_schema => $schema, type_id => $cvterm_id, nd_protocol_id => $nd_protocol_id);
my $store_results = $smd->store($processed_filepath);

=head1 DESCRIPTION


=head1 AUTHORS

David Waring <djw64@cornell.edu>

=cut


use strict;
use warnings;
use Moose;
use JSON;

use SGN::Context;


has 'shell_script_dir' => (
    isa => 'Str',
    is => 'ro',
    default => '/bin/sequence_metadata'
);

has 'bcs_schema' => (
    isa => 'Bio::Chado::Schema',
    is => 'rw',
    required => 1
);

has 'type_id' => (
    isa => 'Int',
    is => 'rw'
);

has 'nd_protocol_id' => (
    isa => 'Int',
    is => 'rw'
);



sub BUILD {
    my $self = shift;
}


#
# Preprocess and verify a gff file for the featureprop_json table
# - Remove comments from the original file
# - Sort the file by seqid and start position
# - Check to make sure all of the seqid's exist as features in the database
# - Remove the original file, if processed successfully
#
# Arguments:
# - input: full filepath to the original gff3 file
# - output: full filepath to the processed gff3 file generated by this script
#
# Returns a hash with the following keys:
# - processed: 0 if processing fails, 1 if it succeeds
# - verified: 0 if verification fails, 1 if it succeeds
# - missing_features: list of missing features
# - error: error message
#
sub verify {
    my $self = shift;
    my $input = shift;
    my $output = shift;
    my $c = SGN::Context->new;

    my %results = (
        processed => 0,
        verified => 0
    );

    # PROCESS THE INPUT FILE
    # Remove comments
    # Sort by seqid and start
    # Save to output file
    my $script = $c->get_conf('basepath') . $self->shell_script_dir . "/preprocess_featureprop_json.sh";
    my $cmd = "bash " . $script . " \"" . $input . "\" \"" . $output . "\"";
    my $rv = system($cmd);
    if ($rv == -1) {
        $results{'error'} = "Could not launch pre-processing script: $!";
    }
    elsif (my $s = $rv & 127) { 
        $results{'error'} = "Pre-processing script died from signal $s";
    }
    elsif (my $e = $rv >> 8)  { 
        $results{'error'} = "Pre-processing script exited with code $e"; 
    }

    # VERIFY THE FEATURES
    # Get a unique list of all seqid's
    # Make sure each seqid matches a feature in the database
    if ( $rv == 0 ) {
        $results{'processed'} = 1;
        
        # Remove original file
        unlink $input;

        # Get unique list of features
        my $script = $c->get_conf('basepath') . $self->shell_script_dir . "/get_unique_features.sh";
        my $cmd = "bash " . $script . " \"" . $output . "\"";
        my @features = `$cmd`;

        # Check each feature in the database
        my @missing = ();
        foreach my $feature ( @features ) {
            chomp($feature);
            my $query = "SELECT feature_id FROM public.feature WHERE uniquename=?" ;
            my $sth = $self->bcs_schema->storage->dbh()->prepare($query);
            $sth->execute($feature);
            my ($feature_id) = $sth->fetchrow_array();
            if ( $feature_id eq "" ) {
                push(@missing, $feature);
            }
        }
        my $missing_count = scalar(@missing);
        $results{'missing_features'} = \@missing;

        # Verified successfully if no missing features
        if ( $missing_count == 0 ) {
            $results{'verified'} = 1;
        }
    }

    return(\%results);
}


#
# Store sequence metadata from a gff file to the featureprop_json table
#
# Arguments:
# - input: the full filepath to the gff3 file to parse
# - chunk_size: (optional) max number of items to store in a single database row (default 8000)
#
# Returns a has with the following keys:
# - error: error message
#
sub store {
    my $self = shift;
    my $input = shift;
    my $chunk_size = shift;

    my %results = (
        stored => 0,
        chunks => 0
    );

    # Make sure type_id and nd_protocol_id are set
    if ( !defined $self->type_id || $self->type_id eq '' ) {
       results{'error'} = "Sequence Metadata type_id not set!";
       return(\%results);
    }
    if ( !defined $self->nd_protocol_id || $self->nd_protocol_id eq '' ) {
        results{'error'} = "Sequence Metadata nd_protocol_id not set!";
        return(\%results);
    }

    # Set default chunk size
    if ( !defined $chunk_size || $chunk_size eq '' ) {
        $chunk_size = 8000;
    }

    # Check cvterm id
    my $cvterm = $self->bcs_schema->resultset("Cv::Cvterm")->find({ cvterm_id => $self->type_id });
    if ( !$cvterm ) {
        $results{'error'} = "No matching cvterm found for the specified type id";
        return(\%results);
    }

    # Check nd protocol id
    my $nd_protocol = $self->bcs_schema->resultset("NaturalDiversity::NdProtocol")->find({ nd_protocol_id => $self->nd_protocol_id });
    if ( !$nd_protocol ) {
        $results{'error'} = "No matching nd protocol found for the specified nd protocol id";
        return(\%results);
    }



    # Open the input file
    open(my $fh, '<', $input) or die "Could not open input file\n";

    # Properties of the current chunk
    my $chunk_feature = undef;  # the name of the chunk's feature (if the current line's feature name is different, start a new chunk)
    my $chunk_start = undef;    # the min start position of the chunk's contents
    my $chunk_end = undef;      # the max end position of the chunk's contents
    my @chunk_values = ();      # the chunk's values (to be converted to JSON array)
    my $chunk_count = 0;        # the number of items in the chunk (if the count exceeds the chunk_size, start a new chunk)
    my $total = 0;              # the total number of chunks

    # Parse the input by line
    while ( defined(my $line = <$fh>) ) {
        chomp $line;
        next if ( $line =~ /^#/ );

        # Get data from line
        my @data = split(/\t/, $line);
        my $feature = @data[0] ne "." ? @data[0] : "";
        my $start = @data[3] ne "." ? @data[3] : "";
        my $end = @data[4] ne "." ? @data[4] : "";
        my $score = @data[5] ne "." ? @data[5] : "";
        my $attributes = @data[8] ne "." ? @data[8] : "";

        # Put unknown start / stop positions at 0
        $start = $start eq "" ? 0 : $start;
        $end = $end eq "" ? 0 : $end;

        # Write the current chunk to the database
        # when the feature changes or the chunk size has been reached
        if ( ($chunk_feature && $feature ne $chunk_feature) || $chunk_count > $chunk_size ) {
            _write_chunk($self, $chunk_feature, \@chunk_values, $chunk_start, $chunk_end);

            # Reset chunk properties
            $chunk_feature = undef;
            $chunk_start = undef;
            $chunk_end = undef;
            @chunk_values = ();
            $chunk_count = 0;
            $total++;
        }

        # Parse attributes
        my %attribute_hash = ();
        if ( $attributes ne "." ) {
            my @as = split(/;/, $attributes);
            for my $a (@as) {
                my @kv = split(/=/, $a);
                my $key = @kv[0];
                my $value = @kv[1];
                if ( $key eq "score" || $key eq "start" || $key eq "end" ) {
                    die "Line has reserved key in attribute list (attributes cannot use keys of 'score', 'start' or 'end')\n";
                }
                $attribute_hash{$key} = $value;
            }
        }

        # Set chunk properties
        if ( !$chunk_feature ) {
            $chunk_feature = $feature;
        }
        if ( !$chunk_start || $start < $chunk_start ) {
            $chunk_start = $start
        }
        if ( !$chunk_end || $end > $chunk_end ) {
            $chunk_end = $end;
        }
        my %value = ( score => $score, start => $start, end => $end );
        %value = (%value, %attribute_hash);

        push @chunk_values, \%value;
        $chunk_count++;
    }

    # Write the last chunk
    _write_chunk($self, $chunk_feature, \@chunk_values, $chunk_start, $chunk_end);
    $total++;

    # Return the number of chunks written
    $results{'stored'} = 1;
    $results{'chunks'} = $total;
    return(\%results);
}


#
# Write a chunk / row of sequence metadata to the database
#
sub _write_chunk() {
    my $self = shift;
    my $chunk_feature = shift;
    my $chunk_values = shift;
    my $chunk_start = shift;
    my $chunk_end = shift;

    my $dbh = $self->bcs_schema->storage->dbh();
    my $type_id = $self->type_id;
    my $nd_protocol_id = $self->nd_protocol_id;

    # Get Feature ID
    my $query = "SELECT feature_id FROM public.feature WHERE uniquename=?" ;
    my $sth = $dbh->prepare($query);
    $sth->execute($chunk_feature);
    my ($feature_id) = $sth->fetchrow_array();

    # Check Feature ID
    if ( !$feature_id || $feature_id eq "" ) {
        die "No matching feature for specified seqid [$chunk_feature]\n";
    }

    # Convert values to JSON array string
    my $json_str = encode_json($chunk_values);

    # Insert into the database
    my $insert = "INSERT INTO public.featureprop_json (feature_id, type_id, nd_protocol_id, start_pos, end_pos, json) VALUES (?, ?, ?, ?, ?, ?);";
    my $ih = $dbh->prepare($insert);
    $ih->execute($feature_id, $type_id, $nd_protocol_id, $chunk_start, $chunk_end, $json_str);

    # print STDERR "...Wrote Chunk #$total\n";
}


1;